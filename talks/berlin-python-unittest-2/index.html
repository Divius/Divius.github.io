<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Unit testing Python</title>
                <meta name="author" content="Dmitry Tantsur (divius.inside@gmail.com)">

		<link rel="stylesheet" href="../reveal.js/css/reveal.css">
		<link rel="stylesheet" href="../reveal.js/css/theme/dtantsur.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="../reveal.js/lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi) ? '../reveal.js/css/print/pdf.css' : '../reveal.js/css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
                <style>
                    .reveal pre code { font-size: 75%; }
                    .reveal blockquote { font-style: italic; }
                    .reveal var.file {
                        font-size: 75%;
                        border-top: solid rgb(63, 63, 63);
                        border-left: solid rgb(63, 63, 63);
                        border-right: solid rgb(63, 63, 63);
                        padding-left: 15px;
                        padding-right: 15px;
                    }
                </style>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">

<section>
    <h1 class="title">Unit testing Python</h1>
    <h2>Part 2</h2>
    <br><br>
    <p><small>Dmitry Tantsur (Principal Software Engineer, Red Hat)</small></p>
    <p><small>Slides:
        <a href="https://dtantsur.github.io/talks/berlin-python-unittest-2/">
            dtantsur.github.io/talks/berlin-python-unittest-2</a>
    </small></p>
    <p><small>Part 1:
        <a href="https://dtantsur.github.io/talks/berlin-python-unittest/">
            dtantsur.github.io/talks/berlin-python-unittest</a>
    </small></p>
    <p><small>Code:
        <a href="https://github.com/dtantsur/berlin-python-unittest">
            github.com/dtantsur/berlin-python-unittest</a>
    </small></p>
</section>

<section>
    <h1>Agenda</h1>
    <ul>
        <li>Mocking:
            <ul>
                <li>Mock objects</li>
                <li>Patching objects</li>
                <li>Spec and autospec</li>
            </ul>
        </li>
        <li>Measuring coverage</li>
        <li>Additional runners:
            <ul>
                <li>PyTest</li>
                <li>stestr</li>
                <li>tox</li>
            </ul>
        </li>
        <li>Handly libraries:
            <ul>
                <li>requests-mock</li>
                <li>fixtures</li>
            </ul>
        </li>
    </ul>
</section>

<section> <!-- Mocking -->

<section>
    <h1 class="title">Mocking</h1>
</section>

<section>
    <h1>Mocking</h1>
    <h2>Problem statement</h2>
    <p>How to test code that relies on (a lot of) other code?</p>
    <p>How to test code that relies on something not available in a regular
    testing environment?</p>
</section>

<section>
    <h1>Mocking</h1>
    <h2>Example</h2>
    <div>
        <img src="architecture.svg" alt="Example architecture" style="border: 0">
    </div>
</section>

<section>
    <h1>Mocking</h1>
    <h2>Example</h2>
    <div>
        <img src="mock.svg" alt="Mocks" style="border: 0">
    </div>
</section>

<section>
    <h1>Mocking</h1>
    <h2>Mock objects</h2>
    <p>Magic objects that allow any operations on them and record them for
    future verification.</p>
    <pre><code class="python">from unittest import mock

m = mock.Mock()
r = m.abc(42, cat='meow')
assert isinstance(m.abc, mock.Mock)
assert isinstance(r, mock.Mock)

m.abc.assert_called_once_with(42, cat='meow')
assert r is m.abc.return_value</code></pre>
</section>

<section>
    <h1>Mocking</h1>
    <h2>Mock objects</h2>
    <p>Mocks can simulate functions that return values or raise exceptions.</p>
    <pre><code class="python">from unittest import mock

m = mock.Mock(return_value=42)
assert m() == 42

m = mock.Mock(side_effect=[1, 2])
assert m() == 1
assert m() == 2

m = mock.Mock(side_effect=RuntimeError("boom"))
m()  # raises</code></pre>
</section>

<section>
    <h1>Mocking</h1>
    <h2>Case study: quadratic equation</h2>
    <var class="file">my_utils/roots.py</var>
    <pre><code class="python">import sys

def main():
    try:
        a = int(sys.argv[1])
        b = int(sys.argv[2])
        c = int(sys.argv[3])
    except IndexError:
        sys.exit('3 arguments required')
    except ValueError:
        sys.exit('all arguments must be integers')
    print(roots(a, b, c))

if __name__ == '__main__':
    main()</code></pre>
</section>

<section>
    <h1>Mocking</h1>
    <h2>Case study: quadratic equation</h2>
    <p>Problems:</p>
    <ul>
        <li>provide values for sys.argv</li>
        <li>test how sys.exit is called</li>
        <li>test how print is called</li>
    </ul>
</section>

<section>
    <h1>Mocking</h1>
    <h2>Case study: quadratic equation</h2>
    <pre><code class="python">class MainTest(unittest.TestCase):

    @mock.patch('sys.argv', [None, '1', '-3', '2'])
    @mock.patch('builtins.print')
    def test_correct(self, mock_print):
        roots.main()
        mock_print.assert_called_once_with((1.0, 2.0))</code></pre>
</section>

<section>
    <h1>Forms of mock.patch</h1>
    <h2>Pure replacement</h2>
    <pre><code class="python">import sys

class MainTest(unittest.TestCase):

    @mock.patch('sys.argv', [None, '1', '-3', '2'])
    def test_patch(self):
        # sys.argv is equal to the replacement value here

    @mock.patch.object(sys, 'argv', [None, '1', '-3', '2'])
    def test_patch_object(self):
        # ...</code></pre>
</section>

<section>
    <h1>Forms of mock.patch</h1>
    <h2>Creating of Mock object</h2>
    <pre><code class="python">import builtins

class MainTest(unittest.TestCase):

    @mock.patch('builtins.print')
    def test_patch(self, mock_print):
        # calling print() here calls mock_print instead

    @mock.patch(builtins, 'print')
    def test_patch_object(self, mock_print):
        # ...</code></pre>
</section>

<section>
    <h1>Forms of mock.patch</h1>
    <h2>The same at the class level</h2>
    <pre><code class="python">import builtins

@mock.patch('builtins.print')
class MainTest(unittest.TestCase):

    def test_patch(self, mock_print):
        # calling print() here calls mock_print instead

    def test_2(self, mock_print):
        # ...</code></pre>
    <p>This is equivalent to adding the decorator to each test method.</p>
</section>

<section>
    <h1>Forms of mock.patch</h1>
    <h2>Inline as a context manager</h2>
    <pre><code class="python">import time

class MainTest(unittest.TestCase):

    def test_patch(self):
        with mock.patch('time.time') as mock_time:
            # calling time.time() here calls mock_time
        # but not here

    def test_patch_object(self):
        with mock.patch.object(time, 'time') as mock_time:
            # ...</code></pre>
</section>

</section> <!-- Mocking -->

<section> <!-- Spec and autospec -->

<section>
    <h1 class="title">Spec and autospec</h1>
</section>

<section>
    <h1>Spec and autospec</h1>
    <h2>Problem statement</h2>
    <p>Mock objects can simulate anything.</p>
    <p>How to make them simulate a specific object or function?</p>
    <p>Spot a problem:</p>
    <pre><code class="python">mock_print.asset_called_once_with("Hello")</code></pre>
</section>

<section>
    <h1>Spec and autospec</h1>
    <h2>Mock specs</h2>
    <p>A Mock object accepts a <em>spec</em> - a simulated object.</p>
    <var class="file">mock_spec_demo.py</var>
    <pre><code class="python">class A:
    """The class we are simulating."""
    def x(self, n):
        return n ** 2

m = mock.Mock(spec=A)
print(m.x)
m.y = 42
print(m.y)
print(m.z)</code></pre>
    <p>What will this program output?</p>
</section>

<section>
    <h1>Spec and autospec</h1>
    <h2>Mock specs</h2>
    <pre><code>$ python3 mock_spec_demo.py
&lt;Mock name='mock.x' id='140537902817232'&gt;
42
Traceback (most recent call last):
  File "mock_spec_demo.py", line 13, in &lt;module&gt;
    print(m.z)
  File "/usr/lib64/python3.6/unittest/mock.py", line 582, in __getattr__
    raise AttributeError("Mock object has no attribute %r" % name)
AttributeError: Mock object has no attribute 'z'</code></pre>
    <p>Accessing <em>z</em> causes an error.</p>
</section>

<section>
    <h1>Spec and autospec</h1>
    <h2>Mock specs</h2>
    <p><em>spec_set</em> also enforces setting attributes.</p>
    <var class="file">mock_spec_set_demo.py</var>
    <pre><code class="python">class A:
    """The class we are simulating."""
    def x(self, n):
        return n ** 2

m = mock.Mock(spec_set=A)
print(m.x)
m.y = 42
print(m.y)
print(m.z)</code></pre>
</section>

<section>
    <h1>Spec and autospec</h1>
    <h2>Mock specs</h2>
    <pre><code>$ python3 mock_spec_set_demo.py
&lt;Mock name='mock.x' id='140537902817232'&gt;
Traceback (most recent call last):
  File "mock_spec_set_demo.py", line 11, in &lt;module&gt;
    m.y = 42
  File "/usr/lib64/python3.6/unittest/mock.py", line 688, in __setattr__
    raise AttributeError("Mock object has no attribute '%s'" % name)
AttributeError: Mock object has no attribute 'y'</code></pre>
    <p>Setting <em>y</em> causes an error.</p>
</section>

<section>
    <h1>Spec and autospec</h1>
    <h2>Mock specs</h2>
    <p><em>spec</em> and <em>spec_set</em> can accept a list of attributes.</p>
    <pre><code class="python">m = mock.Mock(spec=['x', 'y'])
m2 = mock.Mock(spec_set=['x', 'y'])</code></pre>
    <p>Or even wrap a real object:</p>
    <pre><code class="python">m = mock.Mock(wraps=A())
assert m.x(2) == 4
m.x.assert_called_once_with(2)</code></pre>
</section>

<section>
    <h1>Spec and autospec</h1>
    <h2>patch autospec</h2>
    <p>The autospec argument of the patch function can even check function
    signatures:</p>
    <var class="file">mock_autospec_demo.py</var>
    <pre><code class="python">class A:
    def x(self, y):
        return y ** 2

@mock.patch.object(A, 'x', autospec=True)
def test(mock_x):
    a = A()
    print(a.x(42))
    print(a.x(z=42))

test()</code></pre>
</section>

<section>
    <h1>Spec and autospec</h1>
    <h2>Mock specs</h2>
    <pre><code>$ python3 mock_autospec_demo.py
&lt;MagicMock name='x()' id='140700038039648'&gt;
Traceback (most recent call last):
  File "mock_autospec_demo.py", line 16, in &lt;module&gt;
    test()
  File "/usr/lib64/python3.6/unittest/mock.py", line 1179, in patched
    return func(*args, **keywargs)
  File "mock_autospec_demo.py", line 13, in test
    print(a.x(z=42))
  File "&lt;string&gt;", line 2, in x
  File "/usr/lib64/python3.6/unittest/mock.py", line 171, in checksig
    sig.bind(*args, **kwargs)
  File "/usr/lib64/python3.6/inspect.py", line 2969, in bind
    return args[0]._bind(args[1:], kwargs)
  File "/usr/lib64/python3.6/inspect.py", line 2884, in _bind
    raise TypeError(msg) from None
TypeError: missing a required argument: 'y'</code></pre>
</section>

<section>
    <h1>Spec and autospec</h1>
    <h2>Case study: quadratic equation</h2>
    <pre><code class="python">@mock.patch('builtins.print', autospec=True)
class MainTest(unittest.TestCase):

    @mock.patch('sys.argv', [None, '1', '-3', '2'])
    def test_correct(self, mock_print):
        roots.main()
        mock_print.assert_called_once_with((1.0, 2.0))

    @mock.patch('sys.exit', autospec=True)
    @mock.patch('sys.argv', [None, '1', '-3'])
    def test_missing_argument(self, mock_exit, mock_print):
        mock_exit.side_effect = RuntimeError
        self.assertRaises(RuntimeError, roots.main)
        mock_exit.assert_called_once_with(
            '3 arguments required')
        mock_print.assert_not_called()</code></pre>
</section>

</section> <!-- Spec and autospec -->

<section> <!-- Coverage -->

<section>
    <h1 class="title">Coverage</h1>
</section>

<section>
    <h1>Coverage</h1>
    <h2>Problem statement</h2>
    <p>I want to know how much of my code is covered by unit tests.</p>
    <p>The answer is the coverage utility
    <a href="https://coverage.readthedocs.io/">coverage.readthedocs.io</a>.</p>
</section>

<section>
    <h1>Coverage</h1>
    <h2>Collect coverage</h2>
    <pre><code>$ coverage3 run -m unittest discover my_utils
.....
----------------------------------------------------------------------
Ran 5 tests in 0.012s

OK</code></pre>
</section>

<section>
    <h1>Coverage</h1>
    <h2>Report coverage</h2>
    <pre><code>$ coverage3 report
Name                           Stmts   Miss  Cover
--------------------------------------------------
my_utils/__init__.py               0      0   100%
my_utils/roots.py                 21      3    86%
my_utils/tests/__init__.py         0      0   100%
my_utils/tests/test_roots.py      21      0   100%
--------------------------------------------------
TOTAL                             42      3    93%</code></pre>
</section>

<section>
    <h1>Coverage</h1>
    <h2>Rich report</h2>
    <p>Collect also branch information:</p>
    <pre><code>$ coverage3 run --branch -m unittest discover my_utils
.....
----------------------------------------------------------------------
Ran 5 tests in 0.012s

OK</code></pre>
</section>

<section>
    <h1>Coverage</h1>
    <h2>Rich report</h2>
    <p>Show what is not covered:</p>
    <pre><code style="font-size: 50%">$ coverage3 report -m
Name                           Stmts   Miss Branch BrPart  Cover   Missing
--------------------------------------------------------------------------
my_utils/__init__.py               0      0      0      0   100%
my_utils/roots.py                 21      3      8      2    83%   24-25, 30, 22-&gt;24, 29-&gt;30
my_utils/tests/__init__.py         0      0      0      0   100%
my_utils/tests/test_roots.py      21      0      2      0   100%
--------------------------------------------------------------------------
TOTAL                             42      3     10      2    90%</code></pre>
</section>

</section> <!-- Coverage -->

<section> <!-- Additional runners -->

<section>
    <h1 class="title">Additional runners</h1>
</section>

<section>
    <h1>Additional runners</h1>
    <p>Running with python3 -m unittest is quite convenient.</p>
    <p>But there are more feature-rich runners for Python unit tests.</p>
</section>

<section>
    <h1>Additional runners</h1>
    <h2>PyTest</h2>
    <p><a href="https://pytest.readthedocs.io/">pytest.readthedocs.io</a></p>
    <ul>
        <li>Completely different approach to writing tests</li>
        <li>Hacks into Python <em>assert</em> statement</li>
        <li>Automagical fixtures based on test method arguments</li>
        <li>Rich plugin architecture</li>
        <li>(Mostly?) compatible with regular tests</li>
    </ul>
</section>

<section>
    <h1>Additional runners</h1>
    <h2>PyTest</h2>
    <pre><code style="font-size: 50%">$ pytest-3
============================= test session starts =============================
platform linux -- Python 3.6.6, pytest-3.4.2, py-1.5.4, pluggy-0.6.0
rootdir: /home/dtantsur/Projects/berlin-python-unittest, inifile:
collected 5 items

my_utils/tests/test_roots.py .....                                      [100%]

========================== 5 passed in 0.02 seconds ===========================</code></pre>
</section>

<section>
    <h1>Additional runners</h1>
    <h2>stestr</h2>
    <p><a href="https://stestr.readthedocs.io/">stestr.readthedocs.io</a></p>
    <ul>
        <li>Select specific tests to run via regular expressions</li>
        <li>Machine-parseable output in subunit format</li>
        <li>Emphasis on parallel execution and streaming results</li>
        <li>Execution time reporting</li>
        <li>Testing framework agnostic</li>
    </ul>
</section>

<section>
    <h1>Additional runners</h1>
    <h2>stestr</h2>
    <pre><code style="font-size: 50%">$ stestr-3 --test-path my_utils/tests/ run
{2} my_utils.tests.test_roots.RootsTest.test_correct [0.000341s] ... ok
{3} my_utils.tests.test_roots.RootsTest.test_negative_a [0.000647s] ... ok
{0} my_utils.tests.test_roots.MainTest.test_correct [0.011246s] ... ok
{0} my_utils.tests.test_roots.MainTest.test_missing_argument [0.004206s] ... ok
{1} my_utils.tests.test_roots.RootsTest.test_negative_discriminant [0.000660s] ... ok

======
Totals
======
Ran: 5 tests in 0.4467 sec.
 - Passed: 5
 - Skipped: 0
 - Expected Fail: 0
 - Unexpected Success: 0
 - Failed: 0
Sum of execute time for each test: 0.0171 sec.

==============
Worker Balance
==============
 - Worker 0 (2 tests) =&gt; 0:00:00.015929
 - Worker 1 (1 tests) =&gt; 0:00:00.000660
 - Worker 2 (1 tests) =&gt; 0:00:00.000341
 - Worker 3 (1 tests) =&gt; 0:00:00.000647</code></pre>
</section>

<section>
    <h1>Additional runners</h1>
    <h2>stestr - real project</h2>
    <pre><code style="font-size: 50%">======
Totals
======
Ran: 5125 tests in 139.0000 sec.
 - Passed: 5113
 - Skipped: 12
 - Expected Fail: 0
 - Unexpected Success: 0
 - Failed: 0
Sum of execute time for each test: 519.9569 sec.

==============
Worker Balance
==============
 - Worker 0 (1280 tests) =&gt; 0:02:12.778625
 - Worker 1 (1280 tests) =&gt; 0:02:11.374847
 - Worker 2 (1281 tests) =&gt; 0:02:10.885204
 - Worker 3 (1284 tests) =&gt; 0:02:07.915481</code></pre>
</section>

<section>
    <h1>Additional runners</h1>
    <h2>Tox - runner for runners</h2>
    <p><strong>tox</strong> simplifies routine task on managing virtual
    environments and running stuff in them.</p>
    <p>Run unit tests on Python 2.7:</p>
    <pre><code>$ tox -epy27</code></pre>
    <p>Run unit tests on the default Python 3:</p>
    <pre><code>$ tox -epy3</code></pre>
    <p>Build a generic environment and run some commands there:</p>
    <pre><code>$ tox -evenv -- python -m some.package</code></pre>
    <p>Alternative: <em>pyenv</em>.</p>
</section>

<section>
    <h1>Tools: tox</h1>
    <h2>Case study: quadratic equation</h2>
    <pre><code style="font-size: 60%">[tox]
envlist = pep8,py3

[testenv]
usedevelop = True
deps =
    # e.g. -r requirements.txt
commands =
    python -m unittest discover my_utils
setenv =
    PYTHONDONTWRITEBYTECODE=1

[testenv:pep8]
basepython = python3
deps =
    flake8
commands =
    flake8 my_utils

[testenv:venv]
commands = {posargs}</code></pre>
</section>

<section>
    <h1>Tools: tox</h1>
    <h2>Case study: quadratic equation</h2>
    <pre><code style="font-size: 60%">$ tox
pep8 develop-inst-noop: /home/dtantsur/Projects/berlin-python-unittest
pep8 installed: flake8==3.5.0,mccabe==0.6.1,-e git+git@github.com:dtantsur/berlin-python-unittest.git@1b9ac65cee9ba031eb5d3bea979ab2be60ffb844#egg=my_utils,pycodestyle==2.3.1,pyflakes==1.6.0
pep8 runtests: PYTHONHASHSEED='2318298329'
pep8 runtests: commands[0] | flake8 my_utils
py3 create: /home/dtantsur/Projects/berlin-python-unittest/.tox/py3
py3 develop-inst: /home/dtantsur/Projects/berlin-python-unittest
py3 installed: -e git+git@github.com:dtantsur/berlin-python-unittest.git@1b9ac65cee9ba031eb5d3bea979ab2be60ffb844#egg=my_utils
py3 runtests: PYTHONHASHSEED='2318298329'
py3 runtests: commands[0] | python -m unittest discover my_utils
.....
----------------------------------------------------------------------
Ran 5 tests in 0.007s

OK
_____________________________________________________________________________________________________ summary _____________________________________________________________________________________________________
  pep8: commands succeeded
  py3: commands succeeded
  congratulations :)</code></pre>
</section>

</section> <!-- Additional runners -->

<section> <!-- Handy libraries -->

<section>
    <h1 class="title">Handly libraries</h1>
</section>

<section>
    <h1>requests-mock</h1>
    <h2>Problem statement</h2>
    <p>How to test code that does complex network interations?</p>
    <p>requests-mock: <a href="https://requests-mock.readthedocs.io/">
        requests-mock.readthedocs.io</a></p>
    <p>Enables pre-defined answers to specified requests.</p>
</section>

<section>
    <h1>requests-mock</h1>
    <h2>Example</h2>
    <pre><code class="python">&gt;&gt;&gt; @requests_mock.Mocker()
... def test_function(m):
...     m.get('http://test.com', text='resp')
...     return requests.get('http://test.com').text
...
&gt;&gt;&gt; test_function()
'resp'</code></pre>
</section>

<section>
    <h1>fixtures</h1>
    <p>The <em>fixtures</em> library provides a format for defining and using
    test fixtures.</p>
    <p>Fixtures are self-contained helpers that ensure some state on test start
    and revert to the initial state after a test finishes.</p>
</section>

<section>
    <h1>fixtures</h1>
    <h2>Writing fixtures</h2>
    <pre><code class="python">import fixtures
import os

class SecretFileFixture(fixtures.Fixture):
    def __init__(self, fname, content='Hello'):
        self.fname = fname
        self.content = content

    def _setUp(self):
        with open(self.fname, 'w') as f:
            f.write(self.content)
        self.addCleanup(lambda: os.unlink(self.fname))</code></pre>
</section>

<section>
    <h1>fixtures</h1>
    <h2>Using fixtures</h2>
    <pre><code class="python">class MyTest(fixtures.TestWithFixtures):
    def setUp(self):
        self.useFixture(SecretFileFixture('/tmp/test'))

    def test_with_file(self):
        assert os.path.exists('/tmp/test')
        # /tmp/test will be present here and deleted after the test ends</code></pre>
    <p>The <em>testtools</em> library provides support for <em>useFixture</em>
    out of box.</p>
</section>

<section>
    <h1>fixtures</h1>
    <h2>Existing fixtures</h2>
    <ul>
        <li><em>MockPatch</em> and <em>MockPatchObject</em></li>
        <li><em>EnvironmentVariable</em></li>
        <li><em>LogHandler</em> and <em>FakeLogger</em></li>
        <li><em>FakePopen</em></li>
        <li><em>TempDir</em> and <em>TempHomeDir</em></li>
        <li><em>PythonPackage</em> and <em>PythonPathEntry</em></li>
        <li>... and many more.</li>
    </ul>
</section>

</section> <!-- Handy libraries -->

<section>
    <h1 class="title">Questions?</h1>
</section>

			</div>
		</div>

		<script src="../reveal.js/lib/js/head.min.js"></script>
		<script src="../reveal.js/js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
                                history: true,
                                transitionSpeed: 'fast',
				dependencies: [
					{ src: '../reveal.js/plugin/markdown/marked.js' },
					{ src: '../reveal.js/plugin/markdown/markdown.js' },
					{ src: '../reveal.js/plugin/notes/notes.js', async: true },
					{ src: '../reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
