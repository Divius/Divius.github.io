<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Unit testing Python</title>
                <meta name="author" content="Dmitry Tantsur (divius.inside@gmail.com)">

		<link rel="stylesheet" href="../reveal.js/css/reveal.css">
		<link rel="stylesheet" href="../reveal.js/css/theme/dtantsur.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="../reveal.js/lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi) ? '../reveal.js/css/print/pdf.css' : '../reveal.js/css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
                <style>
                    .reveal pre code { font-size: 75%; }
                    .reveal blockquote { font-style: italic; }
                    .reveal var.file {
                        font-size: 75%;
                        border-top: solid rgb(63, 63, 63);
                        border-left: solid rgb(63, 63, 63);
                        border-right: solid rgb(63, 63, 63);
                        padding-left: 15px;
                        padding-right: 15px;
                    }
                </style>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">

<section>
    <h1 class="title">Unit testing Python</h1>
    <br><br>
    <p><small>Dmitry Tantsur (Principal Software Engineer, Red Hat)</small></p>
    <p><small>Slides:
        <a href="https://dtantsur.github.io/talks/berlin-python-unittest/">
            dtantsur.github.io/talks/berlin-python-unittest</a>
    </small></p>
    <p><small>Code:
        <a href="https://github.com/dtantsur/berlin-python-unittest">
            github.com/dtantsur/berlin-python-unittest</a>
    </small></p>
</section>

<section>
    <h1>Agenda</h1>
    <ul>
        <li>Automated testing: how and why?</li>
        <li>Writing and running Python tests:
            <ul>
                <li>The unittest package</li>
                <li>Discovering tests</li>
                <li>Assertion methods</li>
            </ul>
        </li>
        <li>Mocking:
            <ul>
                <li>Mock and MagicMock</li>
                <li>Patching objects</li>
            </ul>
        </li>
        <li>Extras:
            <ul>
                <li>Spec and autospec</li>
                <li>Additional runners</li>
                <li>Measuring coverage</li>
            </ul>
        </li>
    </ul>
</section>

<section><!-- Automated testing -->

<section>
    <h1 class="title">Automated testing</h1>
    <h2>How and why?</h2>
</section>

<section>
    <h1>Automated testing</h1>
    <h2>What?</h2>
    <p>Using a program to verify correctness of a program (library, module,
    any piece of software).</p>
</section>

<section>
    <h1>Automated testing</h1>
    <h2>Why?</h2>
    <ul>
        <li>Decisiveness</li>
        <li>Repeatability</li>
        <li>Parallelism</li>
        <li>Coverage</li>
    </ul>
</section>

<section>
    <h1>Automated testing</h1>
    <h2>Types</h2>
    <ul>
        <li>Black box</li>
        <li>White box</li>
    </ul>
</section>

<section>
    <h1>Automated testing</h1>
    <h2>Types</h2>
    <ul>
        <li>Unit</li>
        <li>Integration</li>
        <li>Functional</li>
    </ul>
</section>

<section>
    <h1>Automated testing</h1>
    <h2>Unit testing</h2>
    <div>
        <img src="unit.svg" alt="Testing types: unit" style="border: 0">
    </div>
    <p><small>Usually white box</small></p>
</section>

<section>
    <h1>Automated testing</h1>
    <h2>Integration testing</h2>
    <div>
        <img src="integration.svg" alt="Testing types: integration" style="border: 0">
    </div>
    <p><small>Usually black box</small></p>
</section>

<section>
    <h1>Automated testing</h1>
    <h2>Functional testing</h2>
    <div>
        <img src="functional.svg" alt="Testing types: functional" style="border: 0">
    </div>
    <p><small>Black box</small></p>
</section>

<section>
    <h1>Automated testing</h1>
    <h2>Why unit test?</h2>
    <ul>
        <li>Sanity-check during development</li>
        <li>Help newcomers keep things working</li>
        <li>Document design decision</li>
        <li>Sign of the maturity of the project</li>
    </ul>
</section>

<section>
    <h1>Automated testing</h1>
    <h2>Why unit test?</h2>
    <p>Unit tests do not:
    <ul>
        <li>Guarantee that your code works</li>
        <li>Replace integration testing</li>
        <li>Replace developer's guide</li>
        <li>Have to cover literally everything</li>
    </ul>
</section>

</section><!-- Automated testing -->

<section><!-- Unit test framework -->

<section>
    <h1 class="title">Unit test framework</h1>
</section>

<section>
    <h1>Unit test framework</h1>
    <ul>
        <li>Included in the standard library</li>
        <li>Heavily extended in Python 3</li>
        <li>Plenty 3rd party addons</li>
    </ul>
</section>

<section>
    <h1>Unit test framework</h1>
    <h2>Case study: quadratic equation</h2>
    <p>Package layout:</p>
    <pre><code class="bash">$ find my_utils
my_utils
my_utils/roots.py
my_utils/__init__.py
my_utils/tests
my_utils/tests/__init__.py
my_utils/tests/test_roots.py</code></pre>
</section>

<section>
    <h1>Unit test framework</h1>
    <h2>Case study: quadratic equation</h2>
    <var class="file">my_utils/roots.py</var>
    <pre><code class="python">import math

def roots(a, b, c):
    if not a:
        raise ValueError("a cannot be zero")

    discriminant = b ** 2 - 4 * a * c
    if discriminant &lt; 0:
        raise ValueError("discriminant below zero")

    return ((- b - math.sqrt(discriminant)) / 2 / a,
            (- b + math.sqrt(discriminant)) / 2 / a)
</code></pre>
</section>

<section>
    <h1>Writing unit tests</h1>
    <ul>
        <li>Split the testing into independent checks</li>
        <li>Group individual checks into cases</li>
        <li>Don't forget negative tests</li>
    </ul>
</section>

<section>
    <h1>Unit test framework</h1>
    <h2>Case study: quadratic equation</h2>
    <var class="file">my_utils/tests/test_roots.py</var>
    <pre><code class="python">import unittest
from my_utils import roots

class RootsTest(unittest.TestCase):
    def test_correct(self):
        self.assertEqual(roots.roots(1, -3, 2),
                         (1.0, 2.0))

    def test_negative_a(self):
        self.assertRaises(ValueError,
                          roots.roots, 0, -3, 2)

    def test_negative_discriminant(self):
        self.assertRaises(ValueError,
                          roots.roots, 1, 1, 1)</code></pre>
</section>

<section>
    <h1>Unit test framework</h1>
    <h2>Case study: quadratic equation</h2>
    <p>Running only one test file:</p>
    <pre><code class="bash">$ python3 -m unittest my_utils.tests.test_roots
...
----------------------------------------------------------------------
Ran 3 tests in 0.000s

OK</code></pre>
</section>

<section>
    <h1>Unit test framework</h1>
    <h2>Case study: quadratic equation</h2>
    <p>Detecting and running all tests:</p>
    <pre><code class="bash">$ python3 -m unittest discover my_utils
...
----------------------------------------------------------------------
Ran 3 tests in 0.000s

OK</code></pre>
</section>

<section>
    <h1>Unit test framework</h1>
    <h2>Case study: quadratic equation</h2>
    <p>And this is how it fails:</p>
    <pre><code class="bash" style="font-size: 40%">$ python3 -m unittest discover my_utils
F..
======================================================================
FAIL: test_correct (tests.test_roots.RootsTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/dtantsur/Projects/berlin-python-unittest/my_utils/tests/test_roots.py", line 10, in test_correct
    self.assertEqual(roots(1, -3, 2), (1.0, 2.0))
AssertionError: Tuples differ: (1.0, 1.0) != (1.0, 2.0)

First differing element 1:
1.0
2.0

- (1.0, 1.0)
?       ^

+ (1.0, 2.0)
?       ^


----------------------------------------------------------------------
Ran 3 tests in 0.002s

FAILED (failures=1)
    </code></pre>
</section>

<section>
    <h1>Unit test framework</h1>
    <h2>Quadratic equation: imports</h2>
    <var class="file">my_utils/tests/test_roots.py</var>
    <pre><code class="python">import unittest
from my_utils.roots import roots</code></pre>
    <p>Importing the standard unittest package and our code that we plan on
    testing.</p>
</section>

<section>
    <h1>Unit test framework</h1>
    <h2>Quadratic equation: test case</h2>
    <var class="file">my_utils/tests/test_roots.py</var>
    <pre><code class="python">class RootsTest(unittest.TestCase):
    def test_correct(self):
        # ...

    def test_negative_a(self):
        # ...

    # ...</code></pre>
    <ul>
        <li>A test case is a logical group of tests</li>
        <li>Each test is a method starting with test_</li>
        <li>Each tests one aspect of the tested entity</li>
    </ul>
</section>

<section>
    <h1>Unit test framework</h1>
    <h2>Quadratic equation: equality</h2>
    <var class="file">my_utils/tests/test_roots.py</var>
    <pre><code class="python">def test_correct(self):
    self.assertEqual(roots.roots(1, -3, 2),
                     (1.0, 2.0))</code></pre>
    <ol>
        <li>Calculate the value using the function under test</li>
        <li>Compare it with the known correct result</li>
    </ol>
    <p>Using convenience methods self.assert&lt;***&gt;</p>
</section>

<section>
    <h1>Unit test framework</h1>
    <h2>Quadratic equation: errors</h2>
    <var class="file">my_utils/tests/test_roots.py</var>
    <pre><code class="python">def test_negative_a(self):
    self.assertRaises(ValueError,
                      roots.roots, 0, -3, 2)

def test_negative_discriminant(self):
    self.assertRaises(ValueError,
                      roots.roots, 1, 1, 1)</code></pre>
    <ul>
        <li>Use assertRaises to check that a callable raises an exception
            on invalid input</li>
        <li>Note that we do not call it ourselves!</li>
    </ul>
</section>

<section>
    <h1>Unit test framework</h1>
    <h2>Quadratic equation: errors</h2>
    <var class="file">my_utils/tests/test_roots.py</var>
    <pre><code class="python">def test_negative_a(self):
    self.assertRaisesRegex(ValueError, 'a cannot be zero',
                           roots.roots, 0, -3, 2)

def test_negative_discriminant(self):
    self.assertRaisesRegex(ValueError, 'discriminant below zero',
                           roots.roots, 1, 1, 1)</code></pre>
    <ul>
        <li>Use assertRaisesRegex to validate the error message</li>
        <li>Useful to distinguish between different cases of the same error</li>
    </ul>
</section>

<section>
    <h1>Unit test framework</h1>
    <h2>Available checks</h2>
    <p>assertEqual, assertNotEqual, assertIs, assertIsNot, assertTrue,
    assertFalse, assertIsInstance, assertNotIsInstance, assertIn, assertNotIn,
    assertGreater, assertGreaterEqual, assertLess, assertLessEqual,
    assertRegex, assertNotRegex, assertRaises, assertRaisesRegex, ...</p>
    <p>And even more in 3rd party libraries</p>
</section>

<section>
    <h1>Unit test framework</h1>
    <h2>Preparing for tests</h2>
    <pre><code class="python">class RootsTest(unittest.TestCase):

    def setUp(self):
        # Gets run before every test

    def tearDown(self):
        # Gets run after every test</code></pre>
    <p>Also use addCleanup to clean up after tests.</p>
</section>

</section><!-- Unit test framework -->

<section><!-- Mocking and patching -->

<section>
    <h1 class="title">Mocking</h1>
    <h2>Handling integration points</h2>
</section>

<section>
    <h1>Mocking</h1>
    <h2>Problem statement</h2>
    <p>How to test code that relies on (a lot of) other code?</p>
    <p>How to test code that relies on something not available in a regular
    testing environment?</p>
</section>

<section>
    <h1>Mocking</h1>
    <h2>The mock library</h2>
    <p>Python has the mock library:</p>
    <ul>
        <li>unittest.mock in Python 3 standard library</li>
        <li>just mock on PyPI for Python 2 and 3</li>
    </ul>
</section>

<section>
    <h1>Mocking</h1>
    <h2>Case study: quadratic equation</h2>
    <var class="file">my_utils/roots.py</var>
    <pre><code class="python">import sys

def main():
    try:
        a = int(sys.argv[1])
        b = int(sys.argv[2])
        c = int(sys.argv[3])
    except IndexError:
        sys.exit('3 arguments required')
    except ValueError:
        sys.exit('all arguments must be integers')
    print(roots(a, b, c))

if __name__ == '__main__':
    main()</code></pre>
</section>

<section>
    <h1>Mocking</h1>
    <h2>Case study: quadratic equation</h2>
    <pre><code class="bash">$ python3 -m my_utils.roots
3 arguments required

$ python3 -m my_utils.roots a b c
all arguments must be integers

$ python3 -m my_utils.roots 1 4 4
(-2.0, -2.0)</code></pre>
</section>

<section>
    <h1>Mocking</h1>
    <h2>Case study: quadratic equation</h2>
    <p>Problems:</p>
    <ul>
        <li>provide values for sys.argv</li>
        <li>test how sys.exit is called</li>
        <li>test how print is called</li>
    </ul>
</section>

<section>
    <h1>Mocking</h1>
    <h2>patch function</h2>
    <p>The unittest.mock.patch function allows to replace an object temporary
    while a test is running and restore it back.</p>
    <p>Can be used in many forms, we will only consider some of them.</p>
</section>

<section>
    <h1>Mocking</h1>
    <h2>Case study: quadratic equation</h2>
    <var class="file">my_utils/tests/test_roots.py</var>
    <pre><code>from unittest import mock

class MainTest(unittest.TestCase):

    @mock.patch('sys.argv', [None, '1', '-3', '2'])
    def test_correct(self):
        roots.main()</code></pre>
    <p>Using patch as decorator to automate patching object and restoring
    it after the test.</p>
</section>

<section>
    <h1>Mocking</h1>
    <h2>Case study: quadratic equation</h2>
    <p>Rough equivalent:
    <pre><code>class MainTest(unittest.TestCase):

    def test_correct(self):
        import sys
        old_argv = sys.argv
        sys.argv = [None, '1', '-3', '2']
        try:
            roots.main()  # our actual test
        finally:
            sys.argv = old_argv</code></pre>
</section>

<section>
    <h1>Mocking</h1>
    <h2>patch function</h2>
    <p>This test does not verify that main function does anything.</p>
    <p>To verify that printing is done correctly, we need to replace
    the print function with something that will track calls.</p>
</section>

<section>
    <h1>Mocking</h1>
    <h2>Mock objects</h2>
    <p>Magic objects that allow any operations on them and record them for
    future verification.</p>
    <pre><code class="python">m = mock.Mock()
r = m.abc(42, cat='meow')
assert isinstance(m.abc, mock.Mock)
assert isinstance(r, mock.Mock)

m.abc.assert_called_once_with(42, cat='meow')
assert r is m.abc.return_value</code></pre>
</section>

<section>
    <h1>Mocking</h1>
    <h2>Case study: quadratic equation</h2>
    <pre><code class="python">class MainTest(unittest.TestCase):

    @mock.patch('sys.argv', [None, '1', '-3', '2'])
    @mock.patch('builtins.print')
    def test_correct(self, mock_print):
        roots.main()
        mock_print.assert_called_once_with((1.0, 2.0))</code></pre>
</section>

<section>
    <h1>Mocking</h1>
    <h2>Case study: quadratic equation</h2>
    <p>If we make a mistake, the test will tell us:</p>
    <pre><code class="bash" style="font-size: 40%">$ python3 -m unittest discover my_utils
F...
======================================================================
FAIL: test_correct (tests.test_roots.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/usr/lib64/python3.6/unittest/mock.py", line 1179, in patched
    return func(*args, **keywargs)
  File "/home/dtantsur/Projects/berlin-python-unittest/my_utils/tests/test_roots.py", line 27, in test_correct
    mock_print.assert_called_once_with((2.0, 2.0))
  File "/usr/lib64/python3.6/unittest/mock.py", line 825, in assert_called_once_with
    return self.assert_called_with(*args, **kwargs)
  File "/usr/lib64/python3.6/unittest/mock.py", line 814, in assert_called_with
    raise AssertionError(_error_message()) from cause
AssertionError: Expected call: print((2.0, 2.0))
Actual call: print((1.0, 2.0))

----------------------------------------------------------------------
Ran 4 tests in 0.002s

FAILED (failures=1)</code></pre>
</section>

<section>
    <h1>Mocking</h1>
    <h2>Case study: quadratic equation</h2>
    <p>Handling sys.exit:</p>
    <ul>
        <li>We need to replace it with Mock</li>
        <li>But we also make sure to stop function from executing after calling
            it</li>
    </ul>
    <p>We can make it raise an exception!</p>
</section>

<section>
    <h1>Mocking</h1>
    <h2>Case study: quadratic equation</h2>
    <pre><code class="python">@mock.patch('builtins.print')
class MainTest(unittest.TestCase):

    @mock.patch('sys.argv', [None, '1', '-3', '2'])
    def test_correct(self, mock_print):
        roots.main()
        mock_print.assert_called_once_with((1.0, 2.0))

    @mock.patch('sys.exit')
    @mock.patch('sys.argv', [None, '1', '-3'])
    def test_missing_argument(self, mock_exit, mock_print):
        mock_exit.side_effect = RuntimeError
        self.assertRaises(RuntimeError, roots.main)
        mock_exit.assert_called_once_with(
            '3 arguments required')
        mock_print.assert_not_called()</code></pre>
</section>

<section>
    <h1>Mocking</h1>
    <h2>Summary</h2>
    <p>mock.patch:</p>
    <ul>
        <li>Can be used on methods and classes</li>
        <li>Can replace an object with a given object or with a new mock</li>
        <li>Passes the newly created mock to test methods</li>
    </ul>
</section>

<section>
    <h1>Mocking</h1>
    <h2>Summary</h2>
    <p>Mock:</p>
    <ul>
        <li>Any attribute is also a Mock</li>
        <li>Can be called, result is a Mock</li>
        <li>Can raise exceptions</li>
        <li>Can return specified values (via setting return_value)</li>
    </ul>
</section>

</section><!-- Mocking and patching -->

<section>
    <h1 class="title">Questions?</h1>
    <p><small>Next part:
        <a href="https://dtantsur.github.io/talks/berlin-python-unittest-2/">
            dtantsur.github.io/talks/berlin-python-unittest-2</a>
    </small></p>
</section>


			</div>
		</div>

		<script src="../reveal.js/lib/js/head.min.js"></script>
		<script src="../reveal.js/js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
                                history: true,
                                transitionSpeed: 'fast',
				dependencies: [
					{ src: '../reveal.js/plugin/markdown/marked.js' },
					{ src: '../reveal.js/plugin/markdown/markdown.js' },
					{ src: '../reveal.js/plugin/notes/notes.js', async: true },
					{ src: '../reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
